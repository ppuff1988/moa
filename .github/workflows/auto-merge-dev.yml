name: Auto Merge to Dev

on:
  workflow_run:
    workflows: ['CI Test']
    types:
      - completed

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      has_conflicts: ${{ steps.merge.outputs.has_conflicts }}
      conflict_pr_numbers: ${{ steps.merge.outputs.conflict_pr_numbers }}
    # åªåœ¨ä»¥ä¸‹æ¢ä»¶æ™‚åŸ·è¡Œï¼š
    # 1. CI Test æˆåŠŸ
    # 2. æ˜¯ PR äº‹ä»¶ï¼ˆä¸æ˜¯ pushï¼‰
    # 3. åˆ†æ”¯ç¬¦åˆ feature é¡å‹ï¼ˆfeat/**, fix/**, ç­‰ï¼‰
    # 4. ä¸æ˜¯ dev æˆ– main åˆ†æ”¯
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'pull_request' &&
      (
        startsWith(github.event.workflow_run.head_branch, 'feat/') ||
        startsWith(github.event.workflow_run.head_branch, 'fix/') ||
        startsWith(github.event.workflow_run.head_branch, 'refactor/') ||
        startsWith(github.event.workflow_run.head_branch, 'chore/') ||
        startsWith(github.event.workflow_run.head_branch, 'docs/') ||
        startsWith(github.event.workflow_run.head_branch, 'style/') ||
        startsWith(github.event.workflow_run.head_branch, 'test/')
      )

    steps:
      - uses: actions/github-script@v7
        id: merge
        with:
          script: |
            let hasConflicts = false;
            let conflictPRNumbers = [];
            const associatedPRs = context.payload.workflow_run.pull_requests;

            if (!associatedPRs || associatedPRs.length === 0) {
              console.log('â„¹ï¸ æ­¤ workflow run æ²’æœ‰é—œè¯çš„ PR');
              return;
            }

            for (const associatedPR of associatedPRs) {
              // ç²å–å®Œæ•´çš„ PR è³‡è¨Š
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: associatedPR.number
              });

              // æª¢æŸ¥ PR æ˜¯å¦ç¬¦åˆæ¢ä»¶ (ç›®æ¨™æ˜¯ dev, é draft)
              if (pr.base.ref !== 'dev' || pr.draft) {
                console.log(`â­ï¸ è·³é PR #${pr.number}: ç›®æ¨™ä¸æ˜¯ dev æˆ–æ˜¯ä¸€å€‹ draft`);
                continue;
              }

              const sourceBranch = pr.head.ref;
              const targetBranch = pr.base.ref;

              console.log(`ğŸ” æª¢æŸ¥ PR #${pr.number}: ${sourceBranch} â†’ ${targetBranch}`);

              if (pr.mergeable_state === 'clean' || pr.mergeable_state === 'unstable') {
                // å¯ä»¥ç›´æ¥ merge
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  // ä½¿ç”¨ rebase ä»¥ç¬¦åˆ Require linear history
                  merge_method: 'rebase'
                });

                console.log(`âœ… PR #${pr.number} å·²è‡ªå‹•åˆä½µåˆ° ${targetBranch}`);

                // è‡ªå‹•åˆªé™¤æºåˆ†æ”¯ï¼ˆæ’é™¤ä¿è­·åˆ†æ”¯ï¼‰
                const protectedBranches = ['main', 'dev', 'staging', 'production'];
                const shouldDelete = !protectedBranches.includes(sourceBranch);

                if (shouldDelete) {
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${sourceBranch}`
                    });
                    console.log(`ğŸ—‘ï¸ å·²åˆªé™¤åˆ†æ”¯: ${sourceBranch}`);
                  } catch (error) {
                    console.log(`âš ï¸ åˆªé™¤åˆ†æ”¯å¤±æ•—: ${error.message}`);
                  }
                } else {
                  console.log(`ğŸ”’ ä¿ç•™åˆ†æ”¯ ${sourceBranch}ï¼ˆä¿è­·åˆ†æ”¯ï¼‰`);
                }
              } else if (pr.mergeable_state === 'dirty') {
                console.log(`âŒ PR #${pr.number} æœ‰è¡çªï¼Œå»ºç«‹è£œæ•‘ PR`);
                hasConflicts = true;
                conflictPRNumbers.push(pr.number);

                // å»ºç«‹å”¯ä¸€åˆ†æ”¯åç¨±
                const newBranch = `pr-${pr.number}-conflict-${pr.head.sha.slice(0,7)}`;

                try {
                  // å»ºç«‹æ–°åˆ†æ”¯
                  await github.rest.git.createRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `refs/heads/${newBranch}`,
                    sha: pr.head.sha
                  });

                  // å»ºç«‹æ–°çš„ PR
                  const newPr = await github.rest.pulls.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: `[CONFLICT] ${pr.title}`,
                    head: newBranch,
                    base: pr.base.ref,
                    body: `âŒ è‡ªå‹•åˆä½µå¤±æ•—ï¼Œè«‹æ‰‹å‹•è™•ç†è¡çª\n\nåŸå§‹ PR: #${pr.number}\nåˆä½µç‹€æ…‹: ${pr.mergeable_state}\n\n${pr.body || ''}`
                  });

                  // åŠ ä¸Š label æ¨™è¨˜
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: newPr.data.number,
                    labels: ['merge-conflict', 'needs-attention']
                  });

                  console.log(`ğŸ“Œ è£œæ•‘ PR å·²å»ºç«‹: #${newPr.data.number}`);
                } catch (error) {
                  console.log(`âš ï¸ å»ºç«‹è£œæ•‘ PR å¤±æ•—: ${error.message}`);
                }
              } else {
                console.log(`â³ PR #${pr.number} ç‹€æ…‹: ${pr.mergeable_state}ï¼Œæš«ä¸è™•ç†`);
              }
            }

            // è¼¸å‡ºçµæœä¾›å¾ŒçºŒæ­¥é©Ÿä½¿ç”¨
            core.setOutput('has_conflicts', hasConflicts);
            core.setOutput('conflict_pr_numbers', conflictPRNumbers.join(','));

            if (hasConflicts) {
              console.log(`\nâš ï¸ ç¸½å…± ${conflictPRNumbers.length} å€‹ PR æœ‰è¡çª: ${conflictPRNumbers.join(', ')}`);
            }

  notify:
    name: åˆä½µé€šçŸ¥
    runs-on: ubuntu-latest
    needs: auto-merge
    # åªåœ¨å¯¦éš›åŸ·è¡Œä¸”æœ‰å•é¡Œæ™‚é€šçŸ¥ï¼ˆæ’é™¤è¢«è·³éçš„æƒ…æ³ï¼‰
    if: |
      always() && 
      needs.auto-merge.result != 'skipped' &&
      (needs.auto-merge.result == 'failure' || needs.auto-merge.outputs.has_conflicts == 'true')
    steps:
      - name: ğŸ“£ ç™¼é€åˆä½µé€šçŸ¥
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          format: markdown
          message: |
            ${{ needs.auto-merge.outputs.has_conflicts == 'true' && 'âš ï¸ *Auto Merge: ç™¼ç¾è¡çª*' || 'âŒ *Auto Merge to Dev å¤±æ•—*' }}

            *å°ˆæ¡ˆ:* `${{ github.repository }}`
            *åˆ†æ”¯:* `${{ github.event.workflow_run.head_branch }} â†’ dev`
            *è§¸ç™¼è€…:* `${{ github.event.workflow_run.actor.login }}`

            ${{ needs.auto-merge.outputs.has_conflicts == 'true' && format('âš ï¸ PR æœ‰åˆä½µè¡çªï¼Œå·²å»ºç«‹è£œæ•‘ PR\nåŸå§‹ PR: #{0}', needs.auto-merge.outputs.conflict_pr_numbers) || 'âŒ è‡ªå‹•åˆä½µå¤±æ•—ï¼Œè«‹æª¢æŸ¥éŒ¯èª¤' }}

            [ç«‹å³æŸ¥çœ‹](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
